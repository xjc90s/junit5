= Parameter Resolution

`{ParameterResolver}` defines the `Extension` API for dynamically resolving parameters at
runtime.

If a _test class_ constructor, _test method_, or _lifecycle method_ (see
<<writing-tests-definitions>>) declares a parameter, the parameter must be _resolved_ at
runtime by a `ParameterResolver`. A `ParameterResolver` can either be built-in (see
`{TestInfoParameterResolver}`) or <<extensions-registration,registered by the user>>.
Generally speaking, parameters may be resolved by _name_, _type_, _annotation_, or any
combination thereof.

If you wish to implement a custom `{ParameterResolver}` that resolves parameters based
solely on the type of the parameter, you may find it convenient to extend the
`{TypeBasedParameterResolver}` which serves as a generic adapter for such use cases.

For concrete examples, consult the source code for `{CustomTypeParameterResolver}`,
`{CustomAnnotationParameterResolver}`, and `{MapOfListsTypeBasedParameterResolver}`.

[WARNING]
====
Due to a bug in the byte code generated by `javac` on JDK versions prior to JDK 9,
looking up annotations on parameters directly via the core `java.lang.reflect.Parameter`
API will always fail for _inner class_ constructors (e.g., a constructor in a `@Nested`
test class).

The `{ParameterContext}` API supplied to `ParameterResolver` implementations therefore
includes the following convenience methods for correctly looking up annotations on
parameters. Extension authors are strongly encouraged to use these methods instead of
those provided in `java.lang.reflect.Parameter` in order to avoid this bug in the JDK.

* `boolean isAnnotated(Class<? extends Annotation> annotationType)`
* `Optional<A> findAnnotation(Class<A> annotationType)`
* `List<A> findRepeatableAnnotations(Class<A> annotationType)`
====

[NOTE]
.Accessing the test-scoped `ExtensionContext`
====
You may override the `getTestInstantiationExtensionContextScope(...)` method to return
`TEST_METHOD` to support injecting test specific data into constructor parameters of the
test class instance. Doing so causes a test-specific `{ExtensionContext}` to be used while
resolving constructor parameters, unless the
<<writing-tests-test-instance-lifecycle, test instance lifecycle>> is set to `PER_CLASS`.
====

[TIP]
.Parameter resolution for methods called from extensions
====
Other extensions can also leverage registered `ParameterResolvers` for method and
constructor invocations, using the `{ExecutableInvoker}` available via the
`getExecutableInvoker()` method in the `ExtensionContext`.
====

[[extensions-parameter-resolution-conflicts]]
== Parameter Conflicts

If multiple implementations of `ParameterResolver` that support the same type are
registered for a test, a `ParameterResolutionException` will be thrown, with a
message to indicate that competing resolvers have been discovered. See the following
example:

[source,java,indent=0]
.Conflicting parameter resolution due to multiple resolvers claiming support for integers
----
include::example$java/example/extensions/ParameterResolverConflictDemo.java[tags=user_guide]
----

If the conflicting `ParameterResolver` implementations are applied to different test
methods as shown in the following example, no conflict occurs.

[source,java,indent=0]
.Fine-grained registration to avoid conflict
----
include::example$java/example/extensions/ParameterResolverNoConflictDemo.java[tags=user_guide]
----

If the conflicting `ParameterResolver` implementations need to be applied to the same test
method, you can implement a custom type or custom annotation as illustrated by
`{CustomTypeParameterResolver}` and `{CustomAnnotationParameterResolver}`, respectively.

[source,java,indent=0]
.Custom type to resolve duplicate types
----
include::example$java/example/extensions/ParameterResolverCustomTypeDemo.java[tags=user_guide]
----

A custom annotation makes the duplicate type distinguishable from its counterpart:

[source,java,indent=0]
.Custom annotation to resolve duplicate types
----
include::example$java/example/extensions/ParameterResolverCustomAnnotationDemo.java[tags=user_guide]
----

JUnit includes some built-in parameter resolvers that can cause conflicts if a resolver
attempts to claim their supported types. For example, `{TestInfo}` provides metadata about
tests. See <<writing-tests-dependency-injection>> for details. Third-party frameworks such
as Spring may also define parameter resolvers. Apply one of the techniques in this section
to resolve any conflicts.

Parameterized tests are another potential source of conflict. Ensure that tests annotated
with `@ParameterizedTest` are not also annotated with `@Test` and see
<<writing-tests-parameterized-tests-consuming-arguments>> for more details.
