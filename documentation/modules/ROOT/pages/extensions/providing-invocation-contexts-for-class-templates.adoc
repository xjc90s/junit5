= Providing Invocation Contexts for Class Templates

A `{ClassTemplate}` class can only be executed when at least one
`{ClassTemplateInvocationContextProvider}` is registered. Each such provider is
responsible for providing a `Stream` of `{ClassTemplateInvocationContext}` instances.
Each context may specify a custom display name and a list of additional extensions that
will only be used for the next invocation of the `{ClassTemplate}`.

The following example shows how to write a class template as well as how to register
and implement a `{ClassTemplateInvocationContextProvider}`.

[source,java,indent=0]
.A class template with accompanying extension
----
include::example$java/example/ClassTemplateDemo.java[tags=user_guide]
----

In this example, the class template will be invoked twice, meaning all test methods in
the class template will be executed twice. The display names of the invocations will be
`apple` and `banana` as specified by the invocation context. Each invocation registers a
custom `{TestInstancePostProcessor}` which is used to inject a value into a field. The
output when using the `ConsoleLauncher` is as follows.

....
└─ ClassTemplateDemo ✔
   ├─ apple ✔
   │  ├─ notNull() ✔
   │  └─ wellKnown() ✔
   └─ banana ✔
      ├─ notNull() ✔
      └─ wellKnown() ✔
....

The `{ClassTemplateInvocationContextProvider}` extension API is primarily intended for
implementing different kinds of tests that rely on repetitive invocation of _all_ test
methods in a test class albeit in different contexts — for example, with different
parameters, by preparing the test class instance differently, or multiple times without
modifying the context.
Please refer to the implementations of
<<writing-tests-parameterized-tests, Parameterized Classes>> which uses this extension
point to provide its functionality.
